#!/usr/bin/env python

import rospy
from std_msgs.msg import String
from sensor_msgs.msg import Image as msg_Image
from cv_bridge import CvBridge, CvBridgeError
import sys
import os

import numpy as np
import cv2
import time

from racecar_flexbe_states.msg import Twist_float 

class ImageListener:
    def __init__(self, topic):
        self.topic = topic
        self.bridge = CvBridge()
        self.sub = rospy.Subscriber(topic, msg_Image, self.imageDepthCallback)
	self.pub = rospy.Publisher('/cmd_vel', Twist_float , queue_size=1)
	self.msg = Twist_float()
	

    def imageDepthCallback(self, data):
        try:
	    # we select bgr8 because its the OpenCv encoing by default
	    start_time = time.time()
            cv_image = self.bridge.imgmsg_to_cv2(data, data.encoding)
	    minVal, maxVal, _, _= cv2.minMaxLoc(cv_image)
	    cv_image = cv2.convertScaleAbs(cv_image,alpha=(255/maxVal))
	    ret, thresh = cv2.threshold(cv_image, 240, 255, 0)
	    mask = np.zeros(thresh.shape, 'uint8')

	    x = y = 30
	    w = h = 100
	    mask[y:y+h,x:x+w] = 255
	    res = cv2.bitwise_and(thresh , mask)
	   
	    M = cv2.moments(thresh)

	    cX = int(M['m10'] / M['m00'])
	    cY = int(M['m01'] / M['m00'])

	    cv2.circle(thresh, (cX,cY), 5 , (0, 255, 0), -1)
	    
	    #start_time = time.time()
	    # self.msg.vel = 0
	    # self.msg.angle = angle
        except CvBridgeError as e:
            print(e)
	
	
	#print(self.follow_corridor.curr_steering_angle)
	# self.pub.publish(self.msg)
	cv2.imshow("Image window", res)
	cv2.waitKey(1)
	print( time.time() - start_time)

def main():
    rospy.init_node('image_listener', anonymous=True)
    topic = '/camera/depth/image_rect_raw'
    listener = ImageListener(topic)
    try:
        rospy.spin()
    except KeyboardInterrupt:
	print('Shutting down')
    cv2.destroyAllWindows()

if __name__ == '__main__':
    main()
